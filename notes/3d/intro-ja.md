3Dコースへようこそ！

昔、変数の束縛のカルトがまだ地球に存在していた頃、プログラミング言語はまだかなり原始的でした。たとえば、人々はプログラムを2Dで書いていたため、時間の3次元を無視していました。明らかに、プログラムの時空間の複雑さは3次元であり、このコースではプログラムの時空間ボリュームを最適化する方法を学びます。

以下は、時間旅行志向のプログラミング言語である3D言語の完全なリファレンスです。時空間ボリュームをできるだけ小さくするために、プログラムは時間軸を小さく保つために時間ワープを使用できます。

# 文法

3Dプログラムはセルの2Dグリッドを表すテキストファイルです。行は改行で区切られます。各行内では、セルは非空白のトークンで表され、空白で区切られます。

各行を別々に処理するため、列を揃えるためにセル間に余分な空白を追加することは人間にとってわかりやすいですが、必須ではありません。行は同じ長さである必要はなく、短い行は左揃えと見なされます：右側は空です。

## 利用可能なトークン

* `.` は空のセルを表します
* `-99`から`99`（含む）までの整数はその整数を表します
* 以下の文字
  `<`, `>`, `^`, `v`, `+`, `-`, `*`, `/`, `%`, `@`, `=`, `#`, `S`, `A`, `B`
  は演算子を表します。
  その意味については[演算子リファレンス](#operator-reference)を参照してください。

# セマンティクス

ボードは無限の2Dセルのグリッドです。各セルは空であるか、値を含むことができます。値は任意のサイズの整数か演算子のいずれかです。

プログラムは任意のサイズの整数リテラルを含むことはできません。整数リテラルは`-99`から`99`までの範囲内でのみ可能です。これはソースコードのみの制限です。実行時にはプログラムは任意のサイズの整数を計算できます。

## 基本的な2Dリダクション

時間はティックと呼ばれる離散的な単位で流れます。初期ボードはソースコードと同一であり、時間座標は`t=1`です。各ティックごとに、ボード全体で同時に1ラウンドのリダクションを行います。

[演算子リファレンス](#operator-reference)では、すべての演算子のリダクションルールを定義しています。一般的に、すべての演算子は周囲に対して局所的な書き換えを行います。たとえば、「右に移動」演算子`>`は`x > .`を`. > x`に書き換えます。

演算子も値なので、`+ > .`は`. > +`にリダクションされます。この方法で演算子をシャッフルすることも可能です。

二項演算子（例：`+`、`*`、`-`）は以下のように書き換えます：
```
. y .     .  .   .
x - .  ~> .  -  x-y
. . .     . x-y  .
```

演算子`A`と`B`は解析後に入力値（もしあれば）に置き換えられます。このメカニズムを使用して、プログラムに異なる入力を与えることができます。

演算子`S`はプログラムを終了して結果を送信するために上書きできます。異なる値を送信することはエラーです。同じ値を同時に複数回送信することは問題ありません。

いくつかのリダクション原則：

1. 演算子の前提条件が満たされない場合、リダクションは単に行われません。たとえば、二項演算子が利用できるオペランドが1つだけの場合、他のオペランドが到着するまで何も変わりません。

2. 演算子の出力は出力セルを上書きします。

   `1 > +`は`. > 1`にリダクションされます

3. 値を読み取ると、それが削除/消費されます。

4. 2つの演算子は同時に同じ入力セルから読み取ることができます。両方の演算子は入力値のコピーを受け取り、その後入力値はボードから削除されます。

   `. < 6 > .`は`6 < . > 6`にリダクションされます

5. `3 > . < 3`や`3 > . < 4`のような同じセルへの競合する書き込みはシミュレーションをクラッシュさせます。

6. 各ティックごとに、すべての読み取り（および削除）はすべての書き込みの前に行われます。

   `1 > 2 > .`は`. > 1 > 2`にリダクションされます

### 演算子リファレンス

以下の図では、一般的に`.`は空のセルまたは任意の値を含む非空のセルを表します。読みやすさのためにメタ変数の代わりにドットを使用しています。

矢印は任意のタイプの値（整数または演算子）を移動します。
```
. < x   ~>   x < .         x > .   ~>   . > x


  .            x             x            .
  ^     ~>     ^             v     ~>     v
  x            .             .            x
```

二項算術演算子は整数引数に対してのみリダクションされます。それらは同時に右と下に出力を書き込みます。
```
. y .        .  .  .       . y .        .  .  .
x + .   ~>   .  + x+y      x * .   ~>   .  * x*y
. . .        . x+y .       . . .        . x*y .


. y .        .  .  .
x - .   ~>   .  - x-y
. . .        . x-y .
```

演算子`/`と`%`は商と余りの操作を表します：演算子`/`は結果をゼロに向かって切り捨てます；
`x%y`は`x`と同じ符号を持ちます。

```
. y .        .  .  .       . y .        .  .  .
x / .   ~>   .  / x/y      x % .   ~>   .  % x%y
. . .        . x/y .       . . .        . x%y .
```

等価比較は2つのオペランドが等しい場合にのみリダクションされます。整数と演算子の両方で動作します。

```
. x .        . . .         . y .        . y .
x = .   ~>   . = x         x = .   ~>   x = .  (if x!=y)
. . .        . x .         . . .        . . .
```

対して、非等価演算子はオペランドが等しくない場合にのみリダクションされます：
```
. x .        . x .         . y .        . . .
x # .   ~>   x # .         x # .   ~>   . # y  (if x!=y)
. . .        . . .         . . .        . x .
```

演算子`A`と`B`にはリダクションルールが定義されていません。これらはプログラムコード内に現れるかもしれませんが、解析後に即座に入力値（もしあれば）に置き換えられます。

演算子`S`（「送信」）にもリダクションルールが定義されていません。プログラムは演算子`S`を結果値で上書きすることで結果を送信します。

時間ワープ演算子については[その独自のセクション](#time-warp)を参照してください。

## スコアリング

スコアはプログラムの総時空間ボリュームです：
* 使用された最大X座標から使用された最小X座標を引いた値に1を加えたもの
* 使用された最大Y座標から使用された最小Y座標を引いた値に1を加えたもの
* 使用された最大T座標から使用された最小T座標を引いた値に1を加えたもの

この定義では、「使用された」はシミュレーション全体とすべての時間ワープにわたっての範囲です。

## 制限

`1_000_000`ティック後、プログラムは値を送信せずに終了します。その時点での時間座標に関係なく終了します。

## 時間ワープ

プログラムの時間複雑性を最大時間座標として定義される複雑性を減少させるために、時間旅行を使用できます。時間旅行は四元演算子であるワープ演算子によってトリガーされます：

```
 .  v  .
dx  @ dy
 . dt  .
```

これは、ボードの歴史を`dt`タイムステップだけ巻き戻し、この過去のボードで`@`演算子の座標に対して相対的に`(-dx, -dy)`に値`v`を書き込みます（負の符号に注意してください！）。これにより、ターゲットボードの時間座標は変更されずに内容が変更されます。その後、変更された点からシミュレーションが再開されます。

`dt`の最小値は`1`であり、1タイムステップ巻き戻すことを意味します。

```
2 > . .        . > 2 .        2 > . .
. 2 @ 0   ~>   . 2 @ 0   ~>   2 2 @ 0
. . 1 .        . . 1 .        . . 1 .
```

### 時間旅行の原則

1. 時間は離散的であり、初期ボードでは`t=1`から始まります。

2. 各ティックごとに時間`t`は1ずつ増加し、ボードはすべての演算子の動作に応じて変更されます。

3. 時間ワープ演算子は過去の任意の時点（初期ボードの`t=1`を含む）まで時間を巻き戻すことができます。

4. `dt=0`の時間ワープは許可されていません。

4. 時間`t`にワープした後、その前の歴史は保持されますが、その後の未来は破棄され、新しいバージョンが再計算されます。

5. 同じティックで2つの異なるワープ演算子が異なる値を同じ宛先セルに書き込もうとした場合、シミュレーションはクラッシュします。

   同じセルに同じ値を書き込むことは問題ありませんし、異なるセルに異なる値を書くことも問題ありません。

6. 同じティックで2つの異なるワープ演算子が異なる時間に移動しようとした場合、シミュレーションはクラッシュします。

7. 送信演算子が上書きされるとすぐに、シミュレーションは停止します。

   ボードには複数の送信演算子を含めることができますが、同時に複数の送信演算子が上書きされた場合、シミュレーションはクラッシュします。

8. ボード上のどの演算子もリダクションできない場合、シミュレーションは結果を送信せずに終了します。

# 例

例として、次のプログラムは、`B`回の時間ループで`A`を加算して`A * B`を計算します（例のために; もちろん`*`演算子もあります）：

```
. . . . 0 . . . .
. B > . = . . . .
. v 1 . . > . . .
. . - . . . + S .
. . . . . ^ . . .
. . v . . 0 > . .
. . . . . . A + .
. 1 @ 6 . . < . .
. . 3 . 0 @ 3 . .
. . . . . 3 . . .
```

これを`A = 3`と`B = 4`で実行すると、このプログラムの時空間ボリュームは`320`です（`vx * vy * vt = 8 * 10 * 4 = 320`）。実行トレースは[3d-example]で確認できます。

# 問題

次の問題が利用可能です：

* [3d1] 最高スコア：4800。
* [3d2] 最高スコア：2400。
* [3d3] 最高スコア：1736。
* [3d4] 最高スコア：2340。
* [3d5] 最高スコア：3456。
* [3d6] 最高スコア：3840。
* [3d7] 最高スコア：13872。
* [3d8] 最高スコア：58500。
* [3d9] 最高スコア：37548。
* [3d10] 最高スコア：187488。
* [3d11]
* [3d12] 最高スコア：105840。

ソリューションを提出するには、以下の形式でICFP式を送信してください：

```
solve 3dX
. . . . .
. . . . .
. . . . .
```

スコアはシークレットテストケースの提出物の時空間複雑さの合計であり、スコアが低いほど良いです。

# テスト

3Dプログラムをテストするには、以下を送信してください：

```
test 3d A B
. . . . .
. . . . .
. . . . .
```

ここで`A`と`B`は整数値であり、それぞれ対応する入力に与えられます。`solve`コマンドとは異なり、`test`コマンドには`4`ティックの制限があります。
