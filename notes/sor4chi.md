# Sor4chi's Notes

## 6/28

### [23:38] Tokenizerの実装完了

Rustで簡易的なTokenizerを実装、それに伴いstringify binを作成。

## 6/29

### [1:54] 暗号文の完全パースと実行に成功

暗号文をパースし、実行することに成功。
今のところバグなし。

### [2:17] できたのでとりあえずSubmitしてみる

language_test出力の`unary # is nota correct`を送信。

```txt
Unknown instruction: \"unary # is not...ect\"
```

language_test出力の`unary # is nota correct`に`echo `をpreprendして送信。

```txt
unary # is not correct

ou scored some points for using the echo service!
```

### [2:36] リーダーボード眺めてて`get lambdaman`できることに気づく

`get lambdaman`を送信。

[これが帰ってきた](./lambdaman/intro.md)

### [2:42] `get speaceship`する

`get spaceship`を送信。

[これが帰ってきた](./spaceship/intro.md)

### [2:49] `get 3d`する

まだできないよって言われた。

### [2:54] スペースシップ問題の仕様を読む

```text
1 2 3
4 5 6
7 8 9
```

っていうキーボードがあって、5を中心として右に下に正の、左に上に負の方向に速度を変えながら移動するゲーム。

### [4:06] ダウンローダー作った

問題が例えばspaceshipだったら`get spaceship1` ~ `get spaceship25`まで全部ダウンロードするやつ。

21以降の問題からダウンロードしてきた入力がまさかのプログラム実行しないと取得できない形式になってることに気づいた。作ってよかったEvaluator。

### [4:28] spaceship1を解く

巡回場所が少ない場合は初期解のビムサである程度とけた。
1,3を提出してかなりいい点が出てるはず。

でもそこまで考慮しなくても単純なTSPをして、経路決めうちで焼きなましとかできそう。

### [5:16] やっぱりおかしいのでhelloを見直す

language_testの出力が単純にエラーを教えてくれていることにやっと気がついた。
修正したらフラグが出てきたのでサブミットして終わり、ごめんなさい。

### [8:12] 2-OPTでspaceship1を解く

2-OPT焼きなまし+頂点間の操作をビームサーチでspaceship1を解いた。結構悪いけどまあ解けてはいるので順位は結構上がった。
ついでにVisualizerも作った。この調子でvisualizerほかの問題にも作っていこう。

### [13:00] パーサーの修正をしたかった・・・

多分再帰Lambda呼び出しに対応できてなくて無限ループになってstack overflowしてる。
ラムダの再帰パースを途中でやめ、変数ありのeval時にできるところまでevalするみたいな感じで調整する必要ありそうだねーって話になった。

現在の実装だと、lambdamanの6,9,19,21がパースできてない。

### [14:00] 大翔が書いたC++のlambdamanコードを提出

67 -> 52 一応パースできたケースは全て通った

### [14:20] ライトニングがあるので3dに取り掛かる

めっちゃめんどそう
3D言語という2Dグリッドのプログラム+離散時間軸の3Dグリッドのプログラムを書く問題。

### [14:30] 3dの仕様を読む


- 無限の2D空間で各セルは空or任意の整数or演算子
- ただし初期プログラムには-99 ~ 99の整数リテラルしか使えない

とりあえずエミュレータ実装しながら考えよう
実装めんどくさすぎる

### [18:38] 最適解のはずなのに順位が低い

バイト数が提出の順位に影響しているので、
自作言語を使ってハフマン符号器を作ってバイト削減することで順位が上がりそう

## 6/30

自作言語パーサーのバグを修正するのに疲れて、特に再帰ラムダの処理が永遠とStack Overflowするので一旦諦めてリセット

### [7:00] 自作処理系でできないなら他言語へのトランスパイルを考える

どうせ関数型の言語なのでそのままLispにトランスパイルしてしまえばいいのではないかというひらめき。
実際に`funcall`と単引数`lambda`の互換だけあれば普通に動くのでそれを考える

### [8:00] Lispにトランスパイルする

トランスパイルした例のlambdaman6などのコードは普通にlispでもStack Overflowするのでダメだった。

### [9:00] Lispで処理を書き、ICFPにデトランスパイルすることを思いつく

Yコンビネータという単引数関数だけで再帰をする仕組みがあるので、これのLisp実装

```lisp
(define Y
  (lambda (f)
    ((lambda (x) (f (lambda (y) ((x x) y)))
     (lambda (x) (f (lambda (y) ((x x) y)))))))
```

をICFPにデトランスパイルするとこうなる

```text
B$ L! B$ L" B$ v" v" L" B$ v! L# B$ B$ v" v" v#
```

### [10:00] Lispで再帰を使ってフィボナッチ数を求める

```text
B$ B$ L! B$ L" B$ v" v" L" B$ v! L# B$ B$ v" v" v# L! L" ? B= v" I# v" B+ B$ v! B- v" I" B$ v! B- v" I# I+
```

できたけど普通にFib(10)は再帰呼び出しが多すぎて無理なことがわかった。

### [11:00] Lispで再帰を使って文字列の繰り返しを生成してみる

Yコンビネータの後ろの`L! L" ? B> v" I" B. S! B$ v! B- v" I" S!`が引数回文字列(S!)を生成する処理で、最後の`I+`(10)が繰り返し回数

```text
B$ B$ L! B$ L" B$ v" v" L" B$ v! L# B$ B$ v" v" v# L! L" ? B> v" I" B. S! B$ v! B- v" I" S! I+
```

## [12:36] 圧縮機構を作る

文字列の繰り返しを生成する処理を使って、文字列の繰り返しを生成する処理を生成する処理を作った。
1/2程度以上に短くなった。やばい。
